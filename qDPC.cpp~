#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <iostream>
#include <string>
#include <stdio.h>
#include <dirent.h>

#define FILENAME_LENGTH 32
#define FILE_HOLENUM_DIGITS 3
using namespace std;
using namespace cv;

#include "include/domeCoordinates.h"

float zMin, zMax, zStep;
string datasetRoot;

Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

class R_image{
  
  public:
        cv::Mat Image;
        int led_num;
        float tan_x;
        float tan_y;
};

void circularShift(Mat img, Mat result, int x, int y){
    int w = img.cols;
    int h  = img.rows;

    int shiftR = x % w;
    int shiftD = y % h;
    
    if (shiftR < 0)
        shiftR += w;
    
    if (shiftD < 0)
        shiftD += h;

    cv::Rect gate1(0, 0, w-shiftR, h-shiftD);
    cv::Rect out1(shiftR, shiftD, w-shiftR, h-shiftD);
    
	 cv::Rect gate2(w-shiftR, 0, shiftR, h-shiftD); //rect(x, y, width, height)
	 cv::Rect out2(0, shiftD, shiftR, h-shiftD);
    
	 cv::Rect gate3(0, h-shiftD, w-shiftR, shiftD);
	 cv::Rect out3(shiftR, 0, w-shiftR, shiftD);
    
	 cv::Rect gate4(w-shiftR, h-shiftD, shiftR, shiftD);
	 cv::Rect out4(0, 0, shiftR, shiftD);
   
    cv::Mat shift1 = img ( gate1 );
    cv::Mat shift2 = img ( gate2 );
    cv::Mat shift3 = img ( gate3 );
    cv::Mat shift4 = img ( gate4 );
   
//   if(shiftD != 0 && shiftR != 0)

	   shift1.copyTo(cv::Mat(result, out1));
	if(shiftR != 0)
    	shift2.copyTo(cv::Mat(result, out2));
	if(shiftD != 0)
    	shift3.copyTo(cv::Mat(result, out3));
	if(shiftD != 0 && shiftR != 0)
    	shift4.copyTo(cv::Mat(result, out4));

    //result.convertTo(result,img.type());
}

/*
int loadImages(string datasetRoot, vector<R_image> *images) {
	DIR *dir;
	struct dirent *ent;
	if ((dir = opendir (datasetRoot.c_str())) != NULL) {
	  
      int num_images = 0;
      cout << "Loading Images..." << endl;
	  while ((ent = readdir (dir)) != NULL) {
		//add to list
		string fileName = ent->d_name;
		string filePrefix = "_scanning_";
		if (fileName.compare(".") != 0 && fileName.compare("..") != 0)
		{
		   string holeNum = fileName.substr(fileName.find(filePrefix)+filePrefix.length(),FILE_HOLENUM_DIGITS);
		   //cout << "Filename is: " << fileName << endl;
		 //  cout << "Filename is: " << fileName << ". HoleNumber is: " << holeNum << endl;
		R_image currentImage;
		currentImage.led_num = atoi(holeNum.c_str());
		//currentImage.Image = imread(datasetRoot + "/" + fileName, CV_8UC1);
		currentImage.Image = imread(datasetRoot + "/" + fileName, -1);//apparently - loads with a?

		currentImage.tan_x = -domeCoordinates[currentImage.led_num][0] / domeCoordinates[currentImage.led_num][2];
		currentImage.tan_y = domeCoordinates[currentImage.led_num][1] / domeCoordinates[currentImage.led_num][2];
		(*images).push_back(currentImage);
		num_images ++;
		}
	  }
	  closedir (dir);
	  return num_images;

	} else {
	  //could not open directory
	  perror ("");
	  return EXIT_FAILURE;
	}
}
*/

void computeFocusDPC(vector<R_image> iStack, int fileCount, float z, int width, int height, int xcrop, int ycrop, Mat* results) {
    int newWidth = width;// - 2*xcrop;
    int newHeight = height;// - 2*ycrop;

    cv::Mat bf_result = cv::Mat(newHeight, newWidth, CV_16UC3, double(0));
	 cv::Mat dpc_result_tb = cv::Mat(newHeight, newWidth, CV_16SC1,double(0));
 	 cv::Mat dpc_result_lr = cv::Mat(newHeight, newWidth, CV_16SC1,double(0));
 	 
    cv::Mat bf_result8 = cv::Mat(newHeight, newWidth, CV_8UC3);
    cv::Mat dpc_result_tb8 = cv::Mat(newHeight, newWidth, CV_8UC1);
    cv::Mat dpc_result_lr8 = cv::Mat(newHeight, newWidth, CV_8UC1);
    
    cv::Mat img;
	 cv::Mat img16;
    cv::Mat shifted = cv::Mat(iStack[0].Image.rows, iStack[0].Image.cols, CV_16UC3,double(0));
    vector<Mat> channels(3);
    for (int idx = 0; idx < fileCount; idx++)
        {
         // Load image, convert to 16 bit grayscale image
         img = iStack[idx].Image;

         // Get home number
         int holeNum = iStack[idx].led_num;

         // Calculate shift based on array coordinates and desired z-distance
         int xShift = (int) round(z*iStack[idx].tan_x);
         int yShift = (int) round(z*iStack[idx].tan_y);

         // Shift the Image in x and y
			circularShift(img, shifted, yShift, xShift);
			
			// Add Brightfield image
			cv::add(bf_result, shifted, bf_result);
			
			// Convert shifted to b/w for DPC
			split(shifted, channels);
			channels[1].convertTo(channels[1],dpc_result_lr.type());
			
			if (find(leftList, leftList + 30, holeNum) != leftList + 30)
             cv::add(dpc_result_lr, channels[1], dpc_result_lr);
         else
             cv::subtract(dpc_result_lr, channels[1], dpc_result_lr);

         if (find(topList, topList + 30, holeNum) != topList + 30)
             cv::add(dpc_result_tb, channels[1], dpc_result_tb);
         else
             cv::subtract(dpc_result_tb, channels[1], dpc_result_tb);

         //float progress = 100*((idx+1) / (float)fileCount);
         //cout << progress << endl;
        }
        
        // Scale the values to 8-bit images
        double min_1, max_1, min_2, max_2, min_3, max_3;
        
        cv::minMaxLoc(bf_result, &min_1, &max_1);
	     bf_result.convertTo(bf_result8, CV_8UC4, 255/(max_1 - min_1), - min_1 * 255.0/(max_1 - min_1));
       
        cv::minMaxLoc(dpc_result_lr.reshape(1), &min_2, &max_2);
        dpc_result_lr.convertTo(dpc_result_lr8, CV_8UC4, 255/(max_2 - min_2), -min_2 * 255.0/(max_2 - min_2));
        
        cv::minMaxLoc(dpc_result_tb.reshape(1), &min_3, &max_3);
        dpc_result_tb.convertTo(dpc_result_tb8, CV_8UC4, 255/(max_3 - min_3), -min_3 * 255.0/(max_3 - min_3));
        
        results[0] = bf_result8;
        results[1] = dpc_result_lr8;
        results[2] = dpc_result_tb8;

}

cv::Mat calcDPC( cv::Mat image1, cv::Mat image2)
{

  /*
  // Background Subtraction
  pMOG = new BackgroundSubtractorMOG(10,2,2,2);
  pMOG->operator()(image1, fgMaskMOG);
  
  namedWindow("Img1", WINDOW_NORMAL);
  imshow("Img1", image1);
  namedWindow("Img1_bg", WINDOW_NORMAL);
  imshow("Img1_bg", fgMaskMOG);

	waitKey(0);
  */
  std::cout << image1.type() << endl;
  std::cout << image2.type() << endl;
  cv::cvtColor(image1,image1,CV_BGR2GRAY);
  cv::cvtColor(image2,image2,CV_BGR2GRAY);
  
  image1.convertTo(image1,CV_32FC1);
  image2.convertTo(image2,CV_32FC1);
  
  cv::Mat tmp1, tmp2;
  cv::subtract(image1, image2, tmp1);
  cv::add(image1, image2, tmp2);
  
  cv::Mat output;
  cv::divide(tmp1,tmp2,output);
  
  tmp1.release();
  tmp2.release();
  
  // Crop the ROI to a circle to get rid of noise
  int16_t circPad = 100;
  cv::Mat circMask(output.size(),CV_32FC1,cv::Scalar(0));
  cv::Point center(cvRound(output.rows/2),cvRound(output.cols/2));
  cv::circle(circMask, center, cvRound(output.rows/2)-circPad ,cv::Scalar(1.0), -1,8,0);
  cv::multiply(output,circMask,output);
	
  double min_1, max_1;
  cv::minMaxLoc(output, &min_1, &max_1);
  output.convertTo(output, CV_8UC1, 255/(max_1 - min_1), - min_1 * 255.0/(max_1 - min_1));

  return output;
}

int* meshgrid_x(int width){
    int * mesh_x = new int[width];
    for(int i = 0; i < width; i++){
        if(i <= (width-1)/2){
            mesh_x[i] = i;
        } else {
            mesh_x[i] = i - width;
        }
    }
    return mesh_x; 
}

int* meshgrid_y(int height){
    int * mesh_y = new int[height];
    for(int i = 0; i < height; i++){
        if(i <= (height-1)/2){
            mesh_y[i] = -1*i;
        } else {
            mesh_y[i] = height - i;
        }
    }
    return mesh_y; 
}

cv::Mat complexConj(cv::Mat input)
{
   Mat output;
   vector<Mat> complexI;
   split(input, complexI);
   complexI[1] = -1*complexI[1];
   Mat planes[] = {complexI[0],complexI[1]};
   merge(planes, 2, output);         // Add to the expanded another plane with zeros
   return output;
}

cv::Mat genTransferFunction(int16_t imageSizeX, int16_t imageSizeY)
{
   cv::Mat pupil(imageSizeX,imageSizeY,CV_32FC1);
   vector<int16_t> angleList;
   
   double objectiveNA  = 0.4;
   double objectiveMag = 20;
   double sigma = 1.1; // Coherence Parameter
   double lambda = 0.625;
   double pxSize = 1.4; // Pixel Size in um
   
   double NA = sigma * objectiveNA;
   double ePxSize = pxSize / objectiveMag;
   double fieldOfViewX = imageSizeX * ePxSize;
   double fieldOfViewY = imageSizeY * ePxSize;
   double duX = imageSizeX / ePxSize;
   double duY = imageSizeY / ePxSize;
   
   cv::Point center(cvRound(imageSizeX/2),cvRound(imageSizeY/2));
   cv::circle(pupil, center, min(duX,duY) * NA ,cv::Scalar(1.0), -1, 8, 0);
   
   namedWindow("Pupil", WINDOW_NORMAL);
	imshow("Pupil", pupil);
	
	waitKey(0);
	
   /*
   cv::Mat S0(imageSizeX,imageSizeY, pupil.type());
   cv::Point center(cvRound(imageSizeX/2),cvRound(imageSizeY/2),cv::Scalar::all(0));
   cv::circle(pupil, center, min(duX,duY) * NA ,cv::Scalar(1.0), -1, 8, 0);
   */
}
/*
int dpcInversion(vector<cv::Mat> dpcList, vector<cv::Mat> transferFunctionList);
{
   


}
*/

int main(int argc, char** argv )
{

   /*
   Inputs:
   RefocusMin
   RefocusStep
   RefocusMax
   DatasetRoot
   */
     
   char * fName_1;
   char * fName_2;
   /*
   if (argc < 1)
   {
      cout << "Error: selectNot enough inputs.\nUSAGE: ./Refocusing zMin zStep zMax DatasetRoot" << endl;
      return 0;
   }else{

   }
   */
         fName_1 = argv[1];
      fName_2 = argv[2];
   
   std::cout << "dpc1: " << fName_1 << std::endl;
   std::cout << "dpc2: " << fName_2 << std::endl;
   
   cv::Mat i1 = imread(fName_1, -1);
   cv::Mat i2 = imread(fName_2, -1);
   
   // Crop to square
   i1 = i1 (CellScopeCropHorz);
   i2 = i2 (CellScopeCropHorz);
   
   //Compute DPC Image
   cv::Mat dpc = calcDPC(i1,i2);
   
   vector<int16_t> angleList;
   angleList.push_back(45);
   angleList.push_back(135);
   
   Mat transFunction45 = imread("dpcTransferFunc_45.tiff", CV_LOAD_IMAGE_ANYDEPTH);
   Mat transFunction135 = imread("dpcTransferFunc_135.tiff", CV_LOAD_IMAGE_ANYDEPTH);
   
   transFunction45.convertTo(transFunction45,CV_64FC1);
   transFunction135.convertTo(transFunction135,CV_64FC1);
   
	normalize(transFunction45, transFunction45, -1, 1, CV_MINMAX);
	normalize(transFunction135, transFunction135, -1, 1, CV_MINMAX);
   
   namedWindow("imag (h)", WINDOW_NORMAL);
   imshow("imag (h)", transFunction45);
   
   waitKey(0);
   
   
   //vector<Mat> h_channels;
   //split(H_45, h_channels);
   /*
   namedWindow("Real (h)", WINDOW_NORMAL);
	normalize(h_channels[0], h_channels[0], 0, 1, CV_MINMAX);
   imshow("Real (H)", h_channels[0]);
   
   namedWindow("Imag (H)", WINDOW_NORMAL);
   normalize(h_channels[1], h_channels[1], 0, 1, CV_MINMAX);
   imshow("Imag (H)", h_channels[1]);
   */
   Mat H_45;
   Mat h_45[] = {Mat::zeros(transFunction45.size(),CV_64F), transFunction45 };
   merge(h_45,2,H_45);
   
   Mat H_135;
   Mat h_135[] = {Mat::zeros(transFunction135.size(),CV_64F),transFunction135 };
   merge(h_135,2,H_135);
   
   /*
   Mat dpc_padded, complex_dpc;                      //expand input image to optimal size
   int m = getOptimalDFTSize( dpc.rows );
   int n = getOptimalDFTSize( dpc.cols ); // on the border add zero values
   copyMakeBorder(dpc, dpc_padded, 0, m - i1.rows, 0, n - i1.cols, BORDER_CONSTANT, Scalar::all(0));
   */
   Mat dpc_padded = dpc;
   Mat complex_dpc;
   Mat planes[] = {Mat_<double>(dpc_padded), Mat::zeros(dpc_padded.size(), CV_64F)};
   merge(planes, 2, complex_dpc);         // Add to the expanded another plane with zeros

   dft(complex_dpc, complex_dpc);            // this way the result may fit in the source matrix
   
   vector<Mat> dpc_ft;
   split(complex_dpc, dpc_ft);
  
   // Show the magnitude of the DPC image)
   /*
   Mat magI;
   magnitude(dpc_ft[0], dpc_ft[1], magI);// planes[0] = magnitude
   magI += Scalar::all(1);                    // switch to logarithmic scale
   log(magI, magI);
   normalize(magI, magI, 0, 1, CV_MINMAX); // Transform the matrix with float values into a
                                            // viewable image form (float between values 0 and 1).
   namedWindow("Spectrum Magnitude", WINDOW_NORMAL);
   imshow("Spectrum Magnitude", magI);
   
   namedWindow("Orig", WINDOW_NORMAL);
	imshow("Orig", dpc);
	
	Mat inv_result;
   dft(complex_dpc, inv_result, DFT_INVERSE|DFT_REAL_OUTPUT); 
   
   //normalize(inv_result, inv_result, 0, 1, CV_MINMAX); // Transform the matrix with float values into a
                                            // viewable image form (float between values 0 and 1).
   namedWindow("Inverse_FT", WINDOW_NORMAL);
   imshow("Inverse_FT", inv_result);
   
   */
   
   // The above works.
	
	double reg = 0.01;
	
	Mat tmp, tmp2, ph_dpc;
	Mat a=complexConj(H_45);
	cout << a.type() << endl;
	cout << complex_dpc.type() << endl;
	cv::multiply(complexConj(H_45),complex_dpc,tmp);
	cv::multiply(cv::abs(H_45),cv::abs(H_45), tmp2);
	cv::divide(tmp, tmp2 + reg, ph_dpc);
	

	
	/*
			vector<Mat> h_channels;
   split(H_45, h_channels);
	namedWindow("Real (H)", WINDOW_NORMAL);
	normalize(h_channels[0], h_channels[0], 0, 1, CV_MINMAX);
   imshow("Real (H)", h_channels[0]);
   
   namedWindow("Imag (H)", WINDOW_NORMAL);
   normalize(h_channels[1], h_channels[1], 0, 1, CV_MINMAX);
   imshow("Imag (H)", h_channels[1]);
	*/

   split(ph_dpc, dpc_ft);
   Mat result = dpc_ft[0];
   dft(ph_dpc, result, DFT_INVERSE|DFT_REAL_OUTPUT); 
   normalize(result, result, 0, 1, CV_MINMAX);
   //result.convertTo(result, CV_32F);
   namedWindow("qPhase", WINDOW_NORMAL);
   imshow("qPhase", result); 
   

   //genTransferFunction(2000,2000);

   
   
   /*
   vector<R_image> * imageStack;
   imageStack = new vector<R_image>;
   int16_t imgCount = loadImages(datasetRoot,imageStack);
	cout << "Processing Refocusing..."<<endl;
	Mat results[3];
	
	for (float zDist = zMin; zDist <= zMax; zDist += zStep)
	{
	   cout << "Processing: " << zDist << "um..." <<endl;
	   computeFocusDPC(*imageStack, imgCount, zDist, imageStack->at(0).Image.cols, imageStack->at(0).Image.rows, 0, 0, results);
	   
	   char bfFilename[FILENAME_LENGTH];
	   char dpcLRFilename[FILENAME_LENGTH];
	   char dpcTBFilename[FILENAME_LENGTH];
	   snprintf(bfFilename,sizeof(bfFilename), "./Refocused/BF_%3f.png",zDist);
	   snprintf(dpcLRFilename,sizeof(dpcLRFilename), "./Refocused/DPCLR_%.2f.png",zDist);
	   snprintf(dpcTBFilename,sizeof(dpcTBFilename), "./Refocused/DPCTB_%.2f.png",zDist);
	   
	   imwrite(bfFilename, results[0]);
	   imwrite(dpcLRFilename, results[1]);
	   imwrite(dpcTBFilename, results[2]);
	}
	cout << "Finished!"<<endl;
   */
	namedWindow("DPC Output", WINDOW_NORMAL);
	imshow("DPC Output", dpc);
	

	waitKey(0);
} 

