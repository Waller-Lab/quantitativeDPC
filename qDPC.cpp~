#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video/background_segm.hpp>
#include <iostream>
#include <string>
#include <stdio.h>
#include <dirent.h>
#include <complex.h>

#define FILENAME_LENGTH 32
#define FILE_HOLENUM_DIGITS 3
using namespace std;
using namespace cv;

#include "include/domeCoordinates.h"

float zMin, zMax, zStep;
string datasetRoot;

Mat fgMaskMOG; //fg mask generated by MOG method
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor

class R_image{
  
  public:
        cv::Mat Image;
        int led_num;
        float tan_x;
        float tan_y;
};

void circularShift(Mat img, Mat result, int x, int y){
    int w = img.cols;
    int h  = img.rows;

    int shiftR = x % w;
    int shiftD = y % h;
    
    if (shiftR < 0)
        shiftR += w;
    
    if (shiftD < 0)
        shiftD += h;

    cv::Rect gate1(0, 0, w-shiftR, h-shiftD);
    cv::Rect out1(shiftR, shiftD, w-shiftR, h-shiftD);
    
	 cv::Rect gate2(w-shiftR, 0, shiftR, h-shiftD); //rect(x, y, width, height)
	 cv::Rect out2(0, shiftD, shiftR, h-shiftD);
    
	 cv::Rect gate3(0, h-shiftD, w-shiftR, shiftD);
	 cv::Rect out3(shiftR, 0, w-shiftR, shiftD);
    
	 cv::Rect gate4(w-shiftR, h-shiftD, shiftR, shiftD);
	 cv::Rect out4(0, 0, shiftR, shiftD);
   
    cv::Mat shift1 = img ( gate1 );
    cv::Mat shift2 = img ( gate2 );
    cv::Mat shift3 = img ( gate3 );
    cv::Mat shift4 = img ( gate4 );
   
//   if(shiftD != 0 && shiftR != 0)

	   shift1.copyTo(cv::Mat(result, out1));
	if(shiftR != 0)
    	shift2.copyTo(cv::Mat(result, out2));
	if(shiftD != 0)
    	shift3.copyTo(cv::Mat(result, out3));
	if(shiftD != 0 && shiftR != 0)
    	shift4.copyTo(cv::Mat(result, out4));

    //result.convertTo(result,img.type());
}


/*
int loadImages(string datasetRoot, vector<R_image> *images) {
	DIR *dir;
	struct dirent *ent;
	if ((dir = opendir (datasetRoot.c_str())) != NULL) {
	  
      int num_images = 0;
      cout << "Loading Images..." << endl;
	  while ((ent = readdir (dir)) != NULL) {
		//add to list
		string fileName = ent->d_name;
		string filePrefix = "_scanning_";
		if (fileName.compare(".") != 0 && fileName.compare("..") != 0)
		{
		   string holeNum = fileName.substr(fileName.find(filePrefix)+filePrefix.length(),FILE_HOLENUM_DIGITS);
		   //cout << "Filename is: " << fileName << endl;
		 //  cout << "Filename is: " << fileName << ". HoleNumber is: " << holeNum << endl;
		R_image currentImage;
		currentImage.led_num = atoi(holeNum.c_str());
		//currentImage.Image = imread(datasetRoot + "/" + fileName, CV_8UC1);
		currentImage.Image = imread(datasetRoot + "/" + fileName, -1);//apparently - loads with a?

		currentImage.tan_x = -domeCoordinates[currentImage.led_num][0] / domeCoordinates[currentImage.led_num][2];
		currentImage.tan_y = domeCoordinates[currentImage.led_num][1] / domeCoordinates[currentImage.led_num][2];
		(*images).push_back(currentImage);
		num_images ++;
		}
	  }
	  closedir (dir);
	  return num_images;

	} else {
	  //could not open directory
	  perror ("");
	  return EXIT_FAILURE;
	}
}
*/

void computeFocusDPC(vector<R_image> iStack, int fileCount, float z, int width, int height, int xcrop, int ycrop, Mat* results) {
    int newWidth = width;// - 2*xcrop;
    int newHeight = height;// - 2*ycrop;

    cv::Mat bf_result = cv::Mat(newHeight, newWidth, CV_16UC3, double(0));
	 cv::Mat dpc_result_tb = cv::Mat(newHeight, newWidth, CV_16SC1,double(0));
 	 cv::Mat dpc_result_lr = cv::Mat(newHeight, newWidth, CV_16SC1,double(0));
 	 
    cv::Mat bf_result8 = cv::Mat(newHeight, newWidth, CV_8UC3);
    cv::Mat dpc_result_tb8 = cv::Mat(newHeight, newWidth, CV_8UC1);
    cv::Mat dpc_result_lr8 = cv::Mat(newHeight, newWidth, CV_8UC1);
    
    cv::Mat img;
	 cv::Mat img16;
    cv::Mat shifted = cv::Mat(iStack[0].Image.rows, iStack[0].Image.cols, CV_16UC3,double(0));
    vector<Mat> channels(3);
    for (int idx = 0; idx < fileCount; idx++)
        {
         // Load image, convert to 16 bit grayscale image
         img = iStack[idx].Image;

         // Get home number
         int holeNum = iStack[idx].led_num;

         // Calculate shift based on array coordinates and desired z-distance
         int xShift = (int) round(z*iStack[idx].tan_x);
         int yShift = (int) round(z*iStack[idx].tan_y);

         // Shift the Image in x and y
			circularShift(img, shifted, yShift, xShift);
			
			// Add Brightfield image
			cv::add(bf_result, shifted, bf_result);
			
			// Convert shifted to b/w for DPC
			split(shifted, channels);
			channels[1].convertTo(channels[1],dpc_result_lr.type());
			
			if (find(leftList, leftList + 30, holeNum) != leftList + 30)
             cv::add(dpc_result_lr, channels[1], dpc_result_lr);
         else
             cv::subtract(dpc_result_lr, channels[1], dpc_result_lr);

         if (find(topList, topList + 30, holeNum) != topList + 30)
             cv::add(dpc_result_tb, channels[1], dpc_result_tb);
         else
             cv::subtract(dpc_result_tb, channels[1], dpc_result_tb);

         //float progress = 100*((idx+1) / (float)fileCount);
         //cout << progress << endl;
        }
        
        // Scale the values to 8-bit images
        double min_1, max_1, min_2, max_2, min_3, max_3;
        
        cv::minMaxLoc(bf_result, &min_1, &max_1);
	     bf_result.convertTo(bf_result8, CV_8UC4, 255/(max_1 - min_1), - min_1 * 255.0/(max_1 - min_1));
       
        cv::minMaxLoc(dpc_result_lr.reshape(1), &min_2, &max_2);
        dpc_result_lr.convertTo(dpc_result_lr8, CV_8UC4, 255/(max_2 - min_2), -min_2 * 255.0/(max_2 - min_2));
        
        cv::minMaxLoc(dpc_result_tb.reshape(1), &min_3, &max_3);
        dpc_result_tb.convertTo(dpc_result_tb8, CV_8UC4, 255/(max_3 - min_3), -min_3 * 255.0/(max_3 - min_3));
        
        results[0] = bf_result8;
        results[1] = dpc_result_lr8;
        results[2] = dpc_result_tb8;

}

cv::Mat calcDPC( cv::Mat image1, cv::Mat image2)
{

  /*
  // Background Subtraction
  pMOG = new BackgroundSubtractorMOG(10,2,2,2);
  pMOG->operator()(image1, fgMaskMOG);
  
  namedWindow("Img1", WINDOW_NORMAL);
  imshow("Img1", image1);
  namedWindow("Img1_bg", WINDOW_NORMAL);
  imshow("Img1_bg", fgMaskMOG);

	waitKey(0);
  */
  std::cout << image1.type() << endl;
  std::cout << image2.type() << endl;
  cv::cvtColor(image1,image1,CV_BGR2GRAY);
  cv::cvtColor(image2,image2,CV_BGR2GRAY);
  
  image1.convertTo(image1,CV_32FC1);
  image2.convertTo(image2,CV_32FC1);
  
  cv::Mat tmp1, tmp2;
  cv::subtract(image1, image2, tmp1);
  cv::add(image1, image2, tmp2);
  
  cv::Mat output;
  cv::divide(tmp1,tmp2,output);
  
  tmp1.release();
  tmp2.release();
  
  // Crop the ROI to a circle to get rid of noise
  int16_t circPad = 100;
  cv::Mat circMask(output.size(),CV_32FC1,cv::Scalar(0));
  cv::Point center(cvRound(output.rows/2),cvRound(output.cols/2));
  cv::circle(circMask, center, cvRound(output.rows/2)-circPad ,cv::Scalar(1.0), -1,8,0);
  cv::multiply(output,circMask,output);
	
  double min_1, max_1;
  cv::minMaxLoc(output, &min_1, &max_1);
  output.convertTo(output, CV_8UC1, 255/(max_1 - min_1), - min_1 * 255.0/(max_1 - min_1));

  return output;
}

cv::Mat qDPC_loop(vector<cv::Mat>dpcList, vector<cv::Mat>angleList, vector<cv::Mat>transferFunctionList)
{
   vector<Mat> complexPlanes;
   
   Mat h[2];
   Mat planes[2];
   
   Mat dpcComplex;
   
   vector<cv::Mat> complexTransferFunctionList;
   vector<cv::Mat> dpcFtList;
   
   for (int idx = 0; idx<transferFunctionList.length(); idx++)
   {
      // Put the transfer functions in complex Mats
      h[0] = Mat::zeros(transferFunctionList.at(idx).size(),CV_64F);
      h[1] = transferFunctionList.at(idx);
      merge(h,2,complexTransferFunctionList.at(idx));
      
      // Take Fourier Transforms of DPC Images
      planes[0] = Mat_<double>(dpcList.at(idx));
      planes[1] = Mat::zeros(dpcList.at(idx).size(), CV_64F);
      
      merge(planes, 2, dpcFtList.at(idx));
      
      
   }
   


   Mat planes[] = {Mat_<double>(dpc), Mat::zeros(dpc.size(), CV_64F)};
   merge(planes, 2, dpc_complex);
   dft(dpc_complex, dpc_ft); 
   //dpc_ft_shifted = Mat::zeros(dpc_ft.size(),dpc_ft
   //fftShift(dpc_ft,dpc_ft);
   split(dpc_ft, complexPlanes);
  
	double reg = 0.1;
	
	Mat dpc_ft_real = complexPlanes[0];
   Mat dpc_ft_imag = complexPlanes[1];
   
   // Result
   Mat ph_dpc_ft_real = Mat::zeros(dpc.size(), CV_64F);
   Mat ph_dpc_ft_imag = Mat::zeros(dpc.size(), CV_64F);
   
   
   complex<double> a (1,2);
   complex<double> b (3,4);
   
   cout << a*b <<endl;
   
   Mat transferFn_sc;
   normalize(transferFn, transferFn_sc, 0, 1, CV_MINMAX); // Transform the matrix with float values into a
   namedWindow("TransferFn", WINDOW_NORMAL);
   imshow("TransferFn", transferFn_sc);
   
   //fftShift(transferFn,transferFn);
	//waitKey(0);
   
   // Try all of this inside of a loop to properly deal with complex values
	for (int i=0; i < dpc_complex.cols; i++){
	   for (int j=0; j < dpc_complex.rows; j++){
	      complex<double> H (0,transferFn.at<double>(i,j));
	      complex<double> Hi (0,-1*transferFn.at<double>(j,i));
	      complex<double> I2 (dpc_ft_real.at<double>(i,j), dpc_ft_imag.at<double>(i,j));
	      
	      complex<double> result;
	      result = ((I2*Hi)/(abs(H)*abs(H) + reg));
	      
	      ph_dpc_ft_real.at<double>(i,j) = result.real();
	      ph_dpc_ft_imag.at<double>(i,j) = result.imag();
	      
	      /*
	      cout << "Index: " << i << ", " << j << endl;
	      cout << "Transfer Function: " << H << endl;
	      cout << "Transfer Function conj: " <<Hi << endl;
	      cout << "dpc Image ft: " << I2 << endl;
	      cout << "result: " << result << endl;
	      */
	   }
	}
	Mat ph_complex_ft, ph_complex;
	planes[0] = ph_dpc_ft_real;
	planes[1] = ph_dpc_ft_imag;
	
	namedWindow("ResultFT", WINDOW_NORMAL);
   imshow("ResultFT", planes[0]);
   merge(planes, 2, ph_complex_ft);    
	dft(ph_complex_ft, ph_complex, DFT_INVERSE|DFT_REAL_OUTPUT);
	split(ph_complex, complexPlanes); 
	
	return complexPlanes[0]; // Real Part
}

cv::Mat qDPC_single(int16_t angle, Mat dpc, Mat transferFn)
{
   vector<Mat> complexPlanes;
   
	Mat H_45;
   Mat h_45[] = {Mat::zeros(transferFn.size(),CV_64F), transferFn };
   merge(h_45,2,H_45);
	
   Mat dpc_complex, dpc_ft;
   Mat planes[] = {Mat_<double>(dpc), Mat::zeros(dpc.size(), CV_64F)};
   merge(planes, 2, dpc_complex);
   dft(dpc_complex, dpc_ft);
   split(dpc_ft, complexPlanes);
  
	double reg = 0.1;
  
	Mat result;
	return dpc;
}


int main(int argc, char** argv )
{

   /*
   Inputs:
   RefocusMin
   RefocusStep
   RefocusMax
   DatasetRoot
   */
     
   char * fName_1;
   char * fName_2;
   /*
   if (argc < 1)
   {
      cout << "Error: selectNot enough inputs.\nUSAGE: ./Refocusing zMin zStep zMax DatasetRoot" << endl;
      return 0;
   }else{

   }
   */
   fName_1 = argv[1];
   fName_2 = argv[2];
   
   std::cout << "dpc1: " << fName_1 << std::endl;
   std::cout << "dpc2: " << fName_2 << std::endl;
   
   cv::Mat i1 = imread(fName_1, -1);
   cv::Mat i2 = imread(fName_2, -1);
   
   // Crop to square
   i1 = i1 (CellScopeCropHorz);
   i2 = i2 (CellScopeCropHorz);
   
   //Compute DPC Image
   cv::Mat dpc = calcDPC(i1,i2);
   
   vector<int16_t> angleList;
   angleList.push_back(45);
   angleList.push_back(135);
   
   Mat transFunction45 = imread("dpcTransferFunc_45.tiff", CV_LOAD_IMAGE_ANYDEPTH);
   Mat transFunction135 = imread("dpcTransferFunc_135.tiff", CV_LOAD_IMAGE_ANYDEPTH);
   
   transFunction45.convertTo(transFunction45,CV_64FC1);
   transFunction135.convertTo(transFunction135,CV_64FC1);
   
	normalize(transFunction45, transFunction45, -1, 1, CV_MINMAX);
	normalize(transFunction135, transFunction135, -1, 1, CV_MINMAX);
	
	vector<cv::Mat> transferFunctions;
	transferFunctionList.push_back = transFunction45;
	transferFunctionList.push_back = transFunction135;
	
	Mat ph_dpc = qDPC_loop(dpcList,angleList,transFunctionList);
   normalize(ph_dpc, ph_dpc, 0, 1, CV_MINMAX);
   
   namedWindow("Phase Image", WINDOW_NORMAL);
   imshow("Phase Image", ph_dpc);
   
   waitKey(0);
	
	//Mat H = Mat_<std::complex<double> >();
	
	//H.at<std::complex<double> >(1,1) = Scalar(0,1);
	
	//cout << H <<endl;
	//cout << H.type() <<endl;
	

   

   
   //vector<Mat> h_channels;
   //split(H_45, h_channels);
   /*
   namedWindow("Real (h)", WINDOW_NORMAL);
	normalize(h_channels[0], h_channels[0], 0, 1, CV_MINMAX);
   imshow("Real (H)", h_channels[0]);
   
   namedWindow("Imag (H)", WINDOW_NORMAL);
   normalize(h_channels[1], h_channels[1], 0, 1, CV_MINMAX);
   imshow("Imag (H)", h_channels[1]);
   
   
   
   Mat H_45;
   Mat h_45[] = {Mat::zeros(transFunction45.size(),CV_64F), transFunction45 };
   merge(h_45,2,H_45);
   
   Mat H_135;
   Mat h_135[] = {Mat::zeros(transFunction135.size(),CV_64F),transFunction135 };
   merge(h_135,2,H_135);
   
   
   Mat dpc_padded, complex_dpc;                      //expand input image to optimal size
   int m = getOptimalDFTSize( dpc.rows );
   int n = getOptimalDFTSize( dpc.cols ); // on the border add zero values
   copyMakeBorder(dpc, dpc_padded, 0, m - i1.rows, 0, n - i1.cols, BORDER_CONSTANT, Scalar::all(0));
   */
   /*
   Mat dpc_padded = dpc;
   Mat complex_dpc;
   Mat planes[] = {Mat_<double>(dpc_padded), Mat::zeros(dpc_padded.size(), CV_64F)};
   merge(planes, 2, complex_dpc);         // Add to the expanded another plane with zeros

   dft(complex_dpc, complex_dpc);            // this way the result may fit in the source matrix
  
  
   // Show the magnitude of the DPC image)
   /*
   Mat magI;
   magnitude(dpc_ft[0], dpc_ft[1], magI);// planes[0] = magnitude
   magI += Scalar::all(1);                    // switch to logarithmic scale
   log(magI, magI);
   normalize(magI, magI, 0, 1, CV_MINMAX); // Transform the matrix with float values into a
                                            // viewable image form (float between values 0 and 1).
   namedWindow("Spectrum Magnitude", WINDOW_NORMAL);
   imshow("Spectrum Magnitude", magI);
   
   namedWindow("Orig", WINDOW_NORMAL);
	imshow("Orig", dpc);
	
	Mat inv_result;
   dft(complex_dpc, inv_result, DFT_INVERSE|DFT_REAL_OUTPUT); 
   
   //normalize(inv_result, inv_result, 0, 1, CV_MINMAX); // Transform the matrix with float values into a
                                            // viewable image form (float between values 0 and 1).
   namedWindow("Inverse_FT", WINDOW_NORMAL);
   imshow("Inverse_FT", inv_result);
   
   */
   
   // The above works.
   /*
   split(ph_dpc, complexPlanes);
	double reg = 0.1;
	
	Mat H = Mat_<std::complex<double> >(h_45[0], h_45[1]);
	Mat Idpc_ft = Mat_<std::complex<double> >(complexPlanes[0], complexPlanes[1]);
	
	// Set up matricies with complex values of H, complex_dpc
	
   Mat numerator = H.t().mul(Idpc_ft);
   Mat ph_dpc = numerator/(cv::abs(H).mul(cv::abs(H))+reg);
   
   Mat magI;
   magnitude(complexPlanes.at(0), complexPlanes.at(1),magI);// planes[0] = magnitude
   magI += Scalar::all(1);                    // switch to logarithmic scale
   log(magI, magI);
   normalize(magI, magI, 0, 1, CV_MINMAX); // Transform the matrix with float values into a
                                            // viewable image form (float between values 0 and 1).
   namedWindow("First method - mag", WINDOW_NORMAL);
   imshow("First method - mag", magI);
   
   waitKey(0);
   /*
   split(complex_dpc, complexPlanes);
   
   Mat dpc_ft_real = complexPlanes[0];
   Mat dpc_ft_imag = complexPlanes[1];
   
   Mat ph_dpc_ft_real = Mat::zeros(dpc_padded.size(), CV_64F);
   Mat ph_dpc_ft_imag = Mat::zeros(dpc_padded.size(), CV_64F);
   
   //transFunction45 = Mat::ones(transFunction45.size(), CV_64FC2); 
   
   // Try all of this inside of a loop to properly deal with complex values
	for (int i=0; i < complex_dpc.cols; i++){
	   for (int j=0; j < complex_dpc.rows; j++){
	      complex<double> H (0,transFunction45.at<double>(i,j));
	      complex<double> Ht (0,-1*transFunction45.at<double>(i,j));
	      
	      //complex<double> H (1,0);
	      //complex<double> Ht (1,0);
	      
	      complex<double> I2 (dpc_ft_real.at<double>(i,j), dpc_ft_imag.at<double>(i,j));
	      
	      complex<double> result ((Ht*I2)/(Ht*H - reg));
	      
	      ph_dpc_ft_real.at<double>(i,j) = result.real();
	      ph_dpc_ft_imag.at<double>(i,j) = result.imag();
	     // cout << result.real() << endl;
	      //cout << result.imag() << endl;
	   }
	}
	
   magnitude(ph_dpc_ft_real, ph_dpc_ft_imag,magI);// planes[0] = magnitude
   magI += Scalar::all(1);                    // switch to logarithmic scale
   log(magI, magI);
   normalize(magI, magI, 0, 1, CV_MINMAX); // Transform the matrix with float values into a
                                            // viewable image form (float between values 0 and 1).
   namedWindow("Spectrum Magnitude", WINDOW_NORMAL);
   imshow("Spectrum Magnitude", magI);
   
   imwrite("out_ft_real.jpeg",ph_dpc_ft_real);
   
   
	Mat result;
	Mat planes2[] = {ph_dpc_ft_real, ph_dpc_ft_imag};
   merge(planes2, 2, result);    
	dft(result, result, DFT_INVERSE);

   split(result, dpc_ft);
   
   ph_dpc_ft_real = dpc_ft[0];
   ph_dpc_ft_imag = dpc_ft[1];
	    
	namedWindow("DPC Input", WINDOW_NORMAL);
	imshow("DPC Input", dpc);
	
	namedWindow("Phase Output (Real)", WINDOW_NORMAL);
	normalize(ph_dpc_ft_real, ph_dpc_ft_real, 0, 1, CV_MINMAX);
	imshow("Phase Output (Real)", ph_dpc_ft_real);
	
	imwrite("test.jpeg",ph_dpc_ft_real);
   
   /*
   namedWindow("Phase Output (Imag)", WINDOW_NORMAL);
	normalize(ph_dpc_ft_imag, ph_dpc_ft_imag, 0, 1, CV_MINMAX);
	imshow("Phase Output (Imag)", ph_dpc_ft_imag);
	*/
	
	//waitKey(0);

	
   
   //genTransferFunction(2000,2000);

   
   
   /*
   vector<R_image> * imageStack;
   imageStack = new vector<R_image>;
   int16_t imgCount = loadImages(datasetRoot,imageStack);
	cout << "Processing Refocusing..."<<endl;
	Mat results[3];
	
	for (float zDist = zMin; zDist <= zMax; zDist += zStep)
	{
	   cout << "Processing: " << zDist << "um..." <<endl;
	   computeFocusDPC(*imageStack, imgCount, zDist, imageStack->at(0).Image.cols, imageStack->at(0).Image.rows, 0, 0, results);
	   
	   char bfFilename[FILENAME_LENGTH];
	   char dpcLRFilename[FILENAME_LENGTH];
	   char dpcTBFilename[FILENAME_LENGTH];
	   snprintf(bfFilename,sizeof(bfFilename), "./Refocused/BF_%3f.png",zDist);
	   snprintf(dpcLRFilename,sizeof(dpcLRFilename), "./Refocused/DPCLR_%.2f.png",zDist);
	   snprintf(dpcTBFilename,sizeof(dpcTBFilename), "./Refocused/DPCTB_%.2f.png",zDist);
	   
	   imwrite(bfFilename, results[0]);
	   imwrite(dpcLRFilename, results[1]);
	   imwrite(dpcTBFilename, results[2]);
	}
	cout << "Finished!"<<endl;
   */
	namedWindow("DPC Output", WINDOW_NORMAL);
	imshow("DPC Output", dpc);
	

	waitKey(0);
} 

